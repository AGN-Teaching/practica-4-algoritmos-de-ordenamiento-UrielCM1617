[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/ke8zCzPd)
[![Open in Codespaces](https://classroom.github.com/assets/launch-codespace-7f7980b617ed060a017424585567c406b6ee15c891e84e1186181d67ecf80aa0.svg)](https://classroom.github.com/open-in-codespaces?assignment_repo_id=13587245)
# Práctica 4: Algoritmos de ordenamiento

## Antecedentes


El problema de ordenamiento se define como:



Entrada: Una secuencia A=〈a1, a2, , an〉 de n números.
Salida: Una permutación A'=〈a'1, a'2, , a'n〉 de los números de la secuencia de A, tal que a'1a'2a'n.



Existen muchos algoritmos que resuelven este problema, siendo la diferencia entre ellos su eficiencia.



En clase estudiamos cinco algoritmos de ordenamiento: insertion sort, selection sort, bubblesort, merge sort y quicksort. Vimos que, en el caso promedio, el tiempo de ejecución de los primeros tres es de orden cuadrático (n2), mientras que el de los últimos dos es proporcional a n n.



¿Qué significa que un algoritmo de ordenamiento tenga eficiencia de n n?
Los algoritmos de ordenamiento con una complejidad de n n Son eficientes y se utilizan para ordenar conjuntos de datos grandes.


## Resultados:


Para poder hacer las pruebas con los algoritmos al mismo tiempo se consideró que el tamaño del arreglo iba ir creciendo de la siguiente manera: 


![Captura de pantalla 2024-01-31 135809](https://github.com/AGN-Teaching/practica-4-algoritmos-de-ordenamiento-UrielCM1617/assets/125332082/89e3b50b-f52f-4daf-a374-ebe81fae1b5d)


y la prueba por cada uno de ellos debíamos de ejecutarla 30 veces, esto quiere decir que para 5 elementos debíamos de ejecutar los 5 algoritmos 30 veces. Por lo que a continuación se mostrarán los resultados de dichas pruebas.

### Análisis:
### Conclusiones:
