[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/ke8zCzPd)
[![Open in Codespaces](https://classroom.github.com/assets/launch-codespace-7f7980b617ed060a017424585567c406b6ee15c891e84e1186181d67ecf80aa0.svg)](https://classroom.github.com/open-in-codespaces?assignment_repo_id=13587245)
# Práctica 4: Algoritmos de ordenamiento

## Antecedentes


El problema de ordenamiento se define como:



Entrada: Una secuencia A=〈a1, a2, , an〉 de n números.
Salida: Una permutación A'=〈a'1, a'2, , a'n〉 de los números de la secuencia de A, tal que a'1a'2a'n.



Existen muchos algoritmos que resuelven este problema, siendo la diferencia entre ellos su eficiencia.



En clase estudiamos cinco algoritmos de ordenamiento: insertion sort, selection sort, bubblesort, merge sort y quicksort. Vimos que, en el caso promedio, el tiempo de ejecución de los primeros tres es de orden cuadrático (n2), mientras que el de los últimos dos es proporcional a n n.



¿Qué significa que un algoritmo de ordenamiento tenga eficiencia de n n?
Los algoritmos de ordenamiento con una complejidad de n n Son eficientes y se utilizan para ordenar conjuntos de datos grandes.


## Resultados:
### Análisis:
### Conclusiones:
